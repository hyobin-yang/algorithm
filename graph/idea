<그래프 문제 아이디어>

13주차
과제 : BJ1012 유기농 배추, BJ1697 숨바꼭질, BJ4963 섬의 개수, BJ7562 나이트의 이동
실전 : BJ1987 알파벳



1. 그래프 알고리즘

[개념]
- 그래프: 노드와 노드 사이에 연결된 간선의 정보를 가지고 있는 자료구조
- 트리와 다르게 루트 노드, 노드 간 부자 관계 없음
- 네트워크 모델

[구현]
- 노드 개수 V, 간선 개수 E
- 인접 행렬: 2차원 배열 사용, 간선의 비용을 아는 데 O(1) 시간 소요
- 인접 리스트: 리스트 사용, O(E)만큼의 메모리 공간 필요, 간선 비용을 아는 데 O(V) 시간 소요


2. 다양한 그래프 알고리즘

(1) 다익스트라 최단 경로 알고리즘
    - 인접 리스트 사용
    - V개의 리스트 생성하여 각 노드와 연결된 모든 간선에 대한 정보를 리스트에 저장
    - 최단 경로 찾는 문제에서 노드와 간선의 개수가 많은 경우 우선순위 큐와 함께 사용

(2) 플로이드 와셜 알고리즘
    - 최단 경로 탐색 알고리즘
    - 인접 행렬 사용
    - 모든 노드에 대하여 다른 노드로 가는 최소 비용을 V**2 크기의 2차원 리스트에 저장
    - 해당 비용 갱신하고 최단 거리 계산
    - 노드의 개수가 적은 경우에 사용
    - O(V**3)

(3) 크루스칼 알고리즘(최소 신장 트리 알고리즘)
    - 신장 트리 중에서 최소 비용으로 만들 수 있는 신장 트리를 찾는 알고리즘
    - 신장 트리: 하나의 그래프가 있을 때 모든 노드를 포함하지만 사이클이 존재하지 않는 부분 그래프
    - 가장 적은 비용으로 모든 노드 연결 가능
    - E = V-1
    - O(ElogE)

    [구현]
        - 간선 데이터를 비용에 따라 오름차순 정렬
        - 간선을 하나씩 확인하며 현재 간선이 사이클 발생시키는지 확인
        - 사이클 X때 최소 신장 트리에 포함
        - 사이클 O때 최소 신장 트리에 포함 X
        - 모든 간선에 반복

    [코드]
    # 특정 원소가 속한 집합을 찾기
    def find_parent(parent, x) :
        # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적 호출
        if parent[x] != x :
            parent[x] = find_parent(parent, parent[x])
        return parent[x]
            
    # 두 원소가 속한 집합을 합치기
    def union_parent(parent, a, b) :
        a = find_parent(parent, a)
        b = find_parent(parent, b)
        if a < b :
            parent[b] = a
        else :
            parent[a] = b
                
    # 노드의 개수와 간선(union 연산)의 개수 입력받기
    v, e = map(int, input().split())
    parent = [0] * (v + 1)	# 부모 테이블 초기화

    # 모든 간선을 담을 리스트와 최종 비용을 담을 변수
    edges = []
    result = 0

    # 부모 테이블상에서, 부모를 자기 자신으로 초기화
    for i in range(1, v + 1) :
        parent[i] = i
            
    # 모든 간선에 대한 정보 입력받기
    for _ in range(e) :
        a, b, cost = map(int, input().split())
        # 비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 비용으로 설정
        edges.append((cost, a, b))
            
    # 간선을 비용순으로 정렬
    edges.sort()

    # 간선을 하나씩 확인하며
    for edge in edges :
        cost, a, b = edge
        # 사이클이 발생하지 않는 경우에만 집합에 포함
        if find_parent(parent, a) != find_parent(parent, b) :
            union_parent(parent, a, b)
            result += cost
                
    print(result)


